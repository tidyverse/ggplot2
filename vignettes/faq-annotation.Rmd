---
title: "FAQ: Annotation"
output: rmarkdown::html_vignette
description: |
  Annotating plots.
vignette: >
  %\VignetteIndexEntry{FAQ: Annotation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{=html}
<style>
  .content h3 {
    margin-top: -30px !important;
  }
  
  details {
    margin-bottom: 40px;
  }
</style>
```
```{r, include = FALSE}
library(ggplot2)
knitr::opts_chunk$set(
  fig.dpi = 300, 
  collapse = TRUE, 
  comment = "#>",
  fig.asp = 0.618,
  fig.width = 6,
  out.width = "80%"
  )
```

  - font
  - color
  - where solution is ggrepel (selective labeling)
  - text instead of geom_point
  - annotate bars / above bars

### How can I annotate my bar plot to display counts for each bar?

Either calculate the counts ahead of time and place them on bars using `geom_text()` or let `ggplot()` calculate them for you and then add them to the plot using `stat_coun()` with `geom = "text"`.

<details>

<summary>See example</summary>

Suppose you have the following bar plot and you want to add the number of cars that fall into each `drv` level on their respective bars.

```{r}
ggplot(mpg, aes(x = drv)) +
  geom_bar()
```

One option is to calculate the counts with `dplyr::count()` and then pass them to the `label` mapping in `geom_text()`.
Note that we expanded the y axis limit to get the numbers to fit on the plot.

```{r}
mpg %>%
  dplyr::count(drv) %>%
  ggplot(aes(x = drv, y = n)) +
  geom_col() +
  geom_text(aes(label = n), vjust = -0.5) +
  coord_cartesian(ylim = c(0, 110))
```

Another option is to let `ggplot()` do the counting for you, and access these counts with `..count..` that is mapped to the labels to be placed on the plot with `stat_count()`.

```{r}
ggplot(mpg, aes(x = drv)) +
  geom_bar() + 
  stat_count(geom = "text", aes(label = ..count..), vjust = -0.5) +
  coord_cartesian(ylim = c(0, 110))
```

</details>

### How can I annotate my stacked bar plot to display counts for each segment?

First calculate the counts for each segment (e.g. with `dplyr::count()`) and then place them on the bars with `geom_text()` using `position_stack(vjust = 0.5)` in the `position` argument to place the values in the middle of the segments.

<details>

<summary>See example</summary>

Suppose you have the following stacked bar plot.

```{r}
ggplot(mpg, aes(x = class, fill = drv)) +
  geom_bar()
```

You can first calculate the counts for each segment with `dplyr::count()`, which will place these values in a column called `n`.

```{r}
mpg %>%
  count(class, drv) 
```

You can then pass this result directly to `ggplot()`, draw the segments with appropriate heights with `y = n` in the `aes`thetic mapping and `geom_col()` to draw the bars, and finally place the counts on the plot with `geom_text()`.

```{r}
mpg %>%
  count(class, drv) %>%
  ggplot(aes(x = class, fill = drv, y = n)) +
  geom_col() +
  geom_text(aes(label = n), size = 3, position = position_stack(vjust = 0.5))
```

</details>

### How can I display proportions (relative frequencies) instead of counts on a bar plot?

Either calculate the prpportions ahead of time and place them on bars using `geom_text()` or let `ggplot()` calculate them for you and then add them to the plot using `stat_coun()` with `geom = "text"`.

<details>

<summary>See example</summary>

Suppose you have the following bar plot but you want to display the proportion of cars that fall into each `drv` level, instead of the count.

```{r}
ggplot(mpg, aes(x = drv)) +
  geom_bar()
```

One option is to calculate the proportions with `dplyr::count()` and then use `geom_col()` to draw the bars

```{r}
mpg %>%
  dplyr::count(drv) %>%
  mutate(prop = n / sum(n)) %>%
  ggplot(aes(x = drv, y = prop)) +
  geom_col()
```

Another option is to let `ggplot()` do the calculation of proportions for you, and access these counts with `..prop..`.
Note that we also need to the `group = 1` mapping for this option.

```{r}
ggplot(mpg, aes(x = drv, y = ..prop.., group = 1)) +
  geom_bar()
```

</details>

